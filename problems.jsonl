{"ingen": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfNodes, seed;\nbool printForSolution;\n\nstring generate_graph();\nint generate_int();\n\nint randomInt(int a, int b) {\n    assert(a <= b);\n    return a + rand() % (b - a + 1);\n}\n\nint maxEdges(int nodes) {\n    assert(nodes >= 0);\n    assert(nodes * (nodes - 1) / 2 >= 0);\n    \n    return nodes * (nodes - 1) / 2;\n}\n\nvoid printGraph(int numberOfNodes, set<pair<int,int>>& edges, bool forSolution) {\n    if(forSolution) {\n        cout << numberOfNodes << \" \" << edges.size() << \"\\n\";\n        for(auto edge: edges) {\n            cout << edge.first << \" \" << edge.second << \"\\n\";\n        }\n    } else { // for prompt\n        cout << \"{\";\n        vector<int> graph[numberOfNodes];\n        for(auto edge: edges) {\n            graph[edge.first].push_back(edge.second);\n            graph[edge.second].push_back(edge.first);\n        }       \n        for (int i = 0; i < numberOfNodes; i++) {\n            cout << \"{\";\n            for (int j = 0; j < graph[i].size(); j++) {\n                cout << graph[i][j];\n                if (j != graph[i].size() - 1) {\n                    cout << \",\";\n                }\n            }\n            cout << \"}\";\n            if (i != numberOfNodes - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\\n\";\n        cout << numberOfNodes << \"\\n\";\n    }\n}\n\n\nint main() {\n    cin >> numberOfNodes >> seed >> printForSolution;\n    srand(seed);\n    assert(numberOfNodes > 0);\n    int numberOfEdges = randomInt(0, maxEdges(numberOfNodes));\n    set<pair<int,int>> edges;\n    while (edges.size() < numberOfEdges) {\n        int from = randomInt(0, numberOfNodes - 1);\n        int to = randomInt(0, numberOfNodes - 1);\n        if (from > to) {\n            swap(from, to);\n        }\n        if (from == to) continue;\n        \n        edges.insert({ from, to });\n    }\n    printGraph(numberOfNodes, edges, printForSolution);\n\n    // cout << generate_graph(size, seed) << \"\\n\" << generate_int(1, size, seed);\n}\n", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> graph;\n\nvector<int> ans;\nbool visited[1000000];\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nint main () {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> res = DFS(0);\n    cout << \"{\";\n    for (int i = 0 ; i < res.size() ; i++) {\n        cout << res[i]; \n        if (i != res.size() - 1) {\n            cout << \",\";\n        }\n    }\n    cout << \"}\\n\";\n\n    return 0;\n}\n", "statement": "Make sure you use a valid c++ vector definition.\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[] = @IN_1\n\nvector<int> ans;\nbool visited[@IN_2];\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nassert(DFS(0) == vector<int>(@ANS));\n```\n", "id": "./tasks/assert-tasks/example-task"}
