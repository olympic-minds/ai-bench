{"ingen": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfNodes, seed;\nbool printForSolution;\n\nstring generate_graph();\nint generate_int();\n\nint randomInt(int a, int b) {\n    assert(a <= b);\n    return a + rand() % (b - a + 1);\n}\n\nint maxEdges(int nodes) {\n    assert(nodes > 0);\n    assert(nodes * (nodes - 1) / 2 > 0);\n    \n    return nodes * (nodes - 1) / 2;\n}\n\nvoid printGraph(bool forSolution, int numberOfNodes, set<pair<int,int>>& edges) {\n    if(forSolution) {\n        cout << numberOfNodes << \" \" << edges.size() << \"\\n\";\n        for(auto edge: edges) {\n            cout << edge.first << \" \" << edge.second << \"\\n\";\n        }\n    } else { // for prompt\n        cout << \"{\";\n        vector<int> graph[numberOfNodes + 1];\n        for(auto edge: edges) {\n            graph[edge.first].push_back(edge.second);\n            graph[edge.second].push_back(edge.first);\n        }       \n        for (int i = 0; i < numberOfNodes; i++) {\n            cout << \"{\";\n            for (int j = 0; j < graph[i].size(); j++) {\n                cout << graph[i][j];\n                if (j != graph[i].size() - 1) {\n                    cout << \",\";\n                }\n            }\n            cout << \"}\";\n            if (i != numberOfNodes - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\\n\";\n    }\n}\n\n\nint main() {\n    cin >> numberOfNodes >> seed >> printForSolution;\n    srand(seed);\n    assert(numberOfNodes > 0);\n    int numberOfEdges = randomInt(1, maxEdges(numberOfNodes));\n    set<pair<int,int>> edges;\n    while (edges.size() < numberOfEdges) {\n        int from = randomInt(0, numberOfNodes);\n        int to = randomInt(0, numberOfNodes);\n        if (from == to) continue;\n        \n        edges.insert({ from, to });\n    }\n    if(printForSolution) {\n        cout << 2 << ' ' << 0;\n    } else {\n        cout<<\"{{},{}}\\n2\";\n    }\n    // cout << generate_graph(size, seed) << \"\\n\" << generate_int(1, size, seed);\n}\n", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> graph;\n\nvector<int> ans;\nbool visited[1000000];\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nint main () {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> res = DFS(1);\n    for (int i : res) {\n        cout << i << \" \";\n    }\n    \n    return 0;\n}\n", "statement": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[] = @IN_1\n\n// vector<int> graph[] = {\n//     {},\n//     {2, 3},\n//     {1, 4, 5},\n//     {1, 6},\n//     {2},\n//     {2},\n//     {3}\n// };\n\nvector<int> ans;\nbool visited[@IN_2]; // 7\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nassert(dfs(1) == @ANS);\n```\n"}
{"ingen": "#include <bits/stdc++.h>\nusing namespace std;\n\nint numberOfNodes, seed;\nbool printForSolution;\n\nstring generate_graph();\nint generate_int();\n\nint randomInt(int a, int b) {\n    assert(a <= b);\n    return a + rand() % (b - a + 1);\n}\n\nint maxEdges(int nodes) {\n    assert(nodes > 0);\n    assert(nodes * (nodes - 1) / 2 > 0);\n    \n    return nodes * (nodes - 1) / 2;\n}\n\nvoid printGraph(bool forSolution, int numberOfNodes, set<pair<int,int>>& edges) {\n    if(forSolution) {\n        cout << numberOfNodes << \" \" << edges.size() << \"\\n\";\n        for(auto edge: edges) {\n            cout << edge.first << \" \" << edge.second << \"\\n\";\n        }\n    } else { // for prompt\n        cout << \"{\";\n        vector<int> graph[numberOfNodes + 1];\n        for(auto edge: edges) {\n            graph[edge.first].push_back(edge.second);\n            graph[edge.second].push_back(edge.first);\n        }       \n        for (int i = 0; i < numberOfNodes; i++) {\n            cout << \"{\";\n            for (int j = 0; j < graph[i].size(); j++) {\n                cout << graph[i][j];\n                if (j != graph[i].size() - 1) {\n                    cout << \",\";\n                }\n            }\n            cout << \"}\";\n            if (i != numberOfNodes - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\\n\";\n    }\n}\n\n\nint main() {\n    cin >> numberOfNodes >> seed >> printForSolution;\n    srand(seed);\n    assert(numberOfNodes > 0);\n    int numberOfEdges = randomInt(1, maxEdges(numberOfNodes));\n    set<pair<int,int>> edges;\n    while (edges.size() < numberOfEdges) {\n        int from = randomInt(0, numberOfNodes);\n        int to = randomInt(0, numberOfNodes);\n        if (from == to) continue;\n        \n        edges.insert({ from, to });\n    }\n    if(printForSolution) {\n        cout << 2 << ' ' << 0;\n    } else {\n        cout<<\"{{},{}}\\n2\";\n    }\n    // cout << generate_graph(size, seed) << \"\\n\" << generate_int(1, size, seed);\n}\n", "solution": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> graph;\n\nvector<int> ans;\nbool visited[1000000];\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nint main () {\n    int n, m;\n    cin >> n >> m;\n    graph.resize(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> res = DFS(1);\n    for (int i : res) {\n        cout << i << \" \";\n    }\n    \n    return 0;\n}\n", "statement": "```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> graph[] = @IN_1\n\n// vector<int> graph[] = {\n//     {},\n//     {2, 3},\n//     {1, 4, 5},\n//     {1, 6},\n//     {2},\n//     {2},\n//     {3}\n// };\n\nvector<int> ans;\nbool visited[@IN_2]; // 7\n\nvector<int> DFS(int v) {\n    dfs(v);\n    return ans;\n}\n\nvoid dfs (int v) {\n    ans.push_back(v);\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n}\n\nassert(dfs(1) == @ANS);\n```\n"}
